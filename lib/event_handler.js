// Generated by CoffeeScript 1.10.0
(function () {
	var vscode = require('vscode'),
		crypto = require('crypto');

	var EventEmitter, EventHandler,
		indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	EventEmitter = require('events').EventEmitter;

	EventHandler = (function () {
		function EventHandler(remoteClient, subscriptions) {
			this.remoteClient = remoteClient;
			this.emitter = new EventEmitter;
			this.projectPath = vscode.workspace.rootPath;
			this.subscriptions = subscriptions;
			this.localChange = false;
			this.userEmail = vscode.workspace.getConfiguration('motepair.userEmail');
			this.lastCursorChange = new Date().getTime();
			this.remoteAction = false;
			this.syncTabsEvents = ['open', 'close'];
			this.fontSize = vscode.workspace.getConfiguration().get("editor.lineHeight") || vscode.workspace.getConfiguration().get("editor.fontSize") || 14;
			this.highlight = vscode.window.createTextEditorDecorationType({
				backgroundColor: 'rgba(31, 161, 93, 0.3)'
			});
			this.subscriptions.push(this.highlight);
			this.remoteCursor = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 0 0 2px",
				// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
				// before: {
				// 	backgroundColor: 'transparent',
				// 	contentIconPath: 'some default image url',
				// 	height: this.fontSize + 'px',
				// 	width: this.fontSize + 'px'
				// }
			});
			this.subscriptions.push(this.remoteCursor);
			this.remoteCursorEnd = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 2px 0 0",
				// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
				// after: {
				// 	backgroundColor: 'transparent',
				// 	contentIconPath: 'some default image url',
				// 	height: this.fontSize + 'px',
				// 	width: this.fontSize + 'px'
				// }
			});
			this.subscriptions.push(this.remoteCursorEnd);
		}

		EventHandler.prototype.getEditor = function (data) {
			var file, modifiedEditor;
			if(this.projectPath.indexOf('/') !== -1) {
				file = data.file.replace(/\\/g, '/');
			} else {
				file = data.file.replace(/\//g, '\\');
			}
			vscode.window.visibleTextEditors.forEach(function(editor) {
				var ref1;
				if (editor.document.uri.path && editor.document.uri.path.indexOf(file) !== -1) {
					modifiedEditor = editor;
				}
			});
			if(modifiedEditor) {
				return modifiedEditor;
			} else {
				this.onopen(data);
				return this.getEditor(data);
			}
		};

		EventHandler.prototype.onopen = function (data) {
			var path, file;
			if(this.projectPath.indexOf('/') !== -1) {
				file = data.file.replace(/\\/g, '/');
			} else {
				file = data.file.replace(/\//g, '\\');
			}
			path = this.projectPath + file;
			this.remoteAction = true;
			vscode.workspace.openTextDocument(path).then((function (_this) {
				return function(TextDocument){
					console.log(TextDocument);
					vscode.window.showTextDocument(TextDocument, vscode.ViewColumn.One, true); //<-- Shouldn't gain focus, but there's a bug: https://github.com/Microsoft/vscode/issues/11247
				};
			})(this));
			return setTimeout((function (_this) {
				return function () {
					return _this.remoteAction = false;
				};
			})(this), 300);
		};

		EventHandler.prototype.onclose = function (data) {
			this.remoteAction = true;

			// Apparently can't close other editors...
			var closedEditor = this.getEditor(data);
			closedEditor.hide();

			// vscode.commands.executeCommand('workbench.action.closeActiveEditor');

			return setTimeout((function (_this) {
				return function () {
					return _this.remoteAction = false;
				};
			})(this), 300);
		};

		EventHandler.prototype.onsave = function (data) {
			var savedEditor = this.getEditor(data);
			savedEditor.document.save();
		};

		EventHandler.prototype.oninsert = function (data) {
			var editor = this.getEditor(data);
			var start = new vscode.Position(data.range[0].line, data.range[0].character);
			var end = new vscode.Position(data.range[1].line, data.range[1].character);
			var range = new vscode.Range(start, end);

			editor.edit(function (textEditorEdit) {
				return textEditorEdit.insert(start, data.text);
			}).then(function (didEdit) {
				console.log("didEdit", didEdit);
				// I don't think I would want this feature by default.
				// Maybe as a dedicated command, or it could be setting defined
				// editor.revealRange(index, vscode.TextEditorRevealType.InCenter);
			});
		};

		EventHandler.prototype.onremove = function (data) {
			var editor = this.getEditor(data);
			var start = new vscode.Position(data.range[0].line, data.range[0].character);
			var end = new vscode.Position(data.range[1].line, data.range[1].character);
			var range = new vscode.Range(start, end);

			editor.edit(function (textEditorEdit) {
				return textEditorEdit.delete(range);
			}).then(function (didDelete) {
				console.log("didDelete", didDelete);
				// I don't think I would want this feature by default.
				// Maybe as a dedicated command, or it could be setting defined
				// editor.revealRange(index, vscode.TextEditorRevealType.InCenter);
			});
		};

		EventHandler.prototype.onselect = function (data) {
			var editor = this.getEditor(data);
			var start = new vscode.Position(data.select.start.line, data.select.start.character);
			var end = new vscode.Position(data.select.end.line, data.select.end.character);
			var range = new vscode.Range(start, end);
			editor.setDecorations(this.highlight, [range]);

			var position = new vscode.Position(data.select.active.line, data.select.active.character);
			range = new vscode.Range(position, position);
			if(position.character === editor.document.lineAt(position.line).range.end.character) {
				editor.setDecorations(this.remoteCursorEnd, [range]);
				editor.setDecorations(this.remoteCursor, []);
			} else {
				editor.setDecorations(this.remoteCursor, [range]);
				editor.setDecorations(this.remoteCursorEnd, []);
			}
		};

		// EventHandler.prototype.oncursor = function (data) {
		// 	var editor = this.getEditor(data);

		// 	// Need to loop through data.cursor in case multiple

		// 	// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
		// 	// if(!this.remoteUserEmail) this.setGravatar(data.userEmail, Math.round(1.5 * this.fontSize));
		// 	var position = new vscode.Position(data.cursor.line, data.cursor.character);
		// 	position = editor.document.validatePosition(position);
		// 	var range = new vscode.Range(position, position);
		// 	if(position.character === editor.document.lineAt(position.line).range.end.character) {
		// 		editor.setDecorations(this.remoteCursorEnd, [range]);
		// 		editor.setDecorations(this.remoteCursor, []);
		// 	} else {
		// 		editor.setDecorations(this.remoteCursor, [range]);
		// 		editor.setDecorations(this.remoteCursorEnd, []);
		// 	}
		// 	// this.setGravatarDuration(editor);

		// 	// I don't think I would want this feature by default.
		// 	// Maybe as a dedicated command, or it could be setting defined
		// 	// return editor.revealRange(data.cursor, vscode.TextEditorRevealType.InCenterIfOutsideViewport)
		// };

		EventHandler.prototype.setGravatar = function (email, size) {
			this.remoteUserEmail = email;
			var emailHash, md5;
			if (!((email != null ? email.length : void 0) > 0)) {
				return;
			}
			md5 = crypto.createHash('md5');
			emailHash = md5.update(email).digest('hex');
			this.remoteCursor.dispose();
			this.remoteCursorEnd.dispose();
			this.remoteCursor = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 0 0 2px",
				before: {
					backgroundColor: 'transparent',
					contentIconPath: 'https://s.gravatar.com/avatar/' + emailHash + '?s=' + size,
					height: size + 'px',
					width: size + 'px'
				}
			});
			this.remoteCursorEnd = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 2px 0 0",
				after: {
					backgroundColor: 'transparent',
					contentIconPath: 'https://s.gravatar.com/avatar/' + emailHash + '?s=' + size,
					height: size + 'px',
					width: size + 'px'
				}
			});
			return;
		};

		EventHandler.prototype.setGravatarDuration = function (editor) {
			var gravatarDelay, now;
			gravatarDelay = 1500;
			now = new Date().getTime();
			if (now - this.lastCursorChange < gravatarDelay) {
				clearInterval(this.gravatarTimeoutId);
			}
			this.gravatarTimeoutId = setTimeout((function (_this) {
				return function () {
					editor.setDecorations(remoteCursor, []);
					return editor.setDecorations(remoteCursorEnd, []);
				};
			})(this), gravatarDelay);
			return this.lastCursorChange = now;
		};

		EventHandler.prototype.sendFileEvents = function (type, file) {
			// check the path coming in
			var data;
			data = {
				a: 'meta',
				type: type,
				data: {
					file: vscode.workspace.asRelativePath(file)
				}
			};
			if (!this.remoteAction) {
				return this.sendMessage(data);
			}
		};

		EventHandler.prototype.sendMessage = function (data) {
			var e, error;
			try {
				return this.remoteClient.send(JSON.stringify(data));
			} catch (error) {
				e = error;
				return this.emitter.emit('socket-not-opened');
			}
		};

		EventHandler.prototype.listen = function () {
			this.remoteClient.on('message', (function (_this) {
				return function (event) {
					var eventType, ref1;
					event = JSON.parse(event);
					eventType = event.actualType || event.type;
					if (_this["on" + eventType] != null) {
						if (vscode.workspace.getConfiguration('motepair').get('syncTabs') || (ref1 = eventType, indexOf.call(_this.syncTabsEvents, ref1) < 0)) {
							return _this["on" + eventType](event.data);
						}
					}
				};
			})(this));
			this.subscriptions.push(vscode.workspace.onDidChangeTextDocument((function (_this) {
				return function (TextDocumentChangeEvent) {
					var data;
					if(TextDocumentChangeEvent.contentChanges[0].text.length === 0){
						data = {
							a: 'meta',
							type: 'cursor', // server filters types, so this will be cursor for now and I'll add another attribute to tell the remote client to remote
							actualType: 'insert',
							data: {
								actualType: 'remove',
								file: vscode.workspace.asRelativePath(TextDocumentChangeEvent.document.uri),
								// Need to send 'selections' for multiple cursors
								range: TextDocumentChangeEvent.contentChanges[0].range
							}
						};
					} else if (TextDocumentChangeEvent.contentChanges[0].text.length > 0) {
						data = {
							a: 'meta',
							type: 'cursor', // server filters types, so this will be cursor for now and I'll add another attribute to tell the remote client to insert
							actualType: 'insert',
							data: {
								actualType: 'insert',
								file: vscode.workspace.asRelativePath(TextDocumentChangeEvent.document.uri),
								// Need to send 'selections' for multiple cursors
								range: TextDocumentChangeEvent.contentChanges[0].range,
								text: TextDocumentChangeEvent.contentChanges[0].text
							}
						};
					}
					return setTimeout(function () {
						_this.sendMessage(data);
					}, 0);
				};
			})(this)));
			// Probably should roll this into cursor
			// this.subscriptions.push(vscode.window.onDidChangeTextEditorSelection((function (_this) {
			// 	return function (TextEditorSelectionChangeEvent) {
			// 		var data;
			// 		data = {
			// 			a: 'meta',
			// 			type: 'cursor',
			// 			data: {
			// 				file: vscode.workspace.asRelativePath(TextEditorSelectionChangeEvent.textEditor.document.uri),
			// 				// Need to send 'selections' for multiple cursors
			// 				cursor: TextEditorSelectionChangeEvent.selections[0].active,
			// 				userEmail: _this.userEmail
			// 			}
			// 		};
			// 		return setTimeout(function () {
			// 			_this.sendMessage(data);
			// 		}, 0);
			// 	};
			// })(this)));
			this.subscriptions.push(vscode.window.onDidChangeTextEditorSelection((function (_this) {
				return function (TextEditorSelectionChangeEvent) {
					var data;
					data = {
						a: 'meta',
						type: 'select',
						data: {
							file: vscode.workspace.asRelativePath(TextEditorSelectionChangeEvent.textEditor.document.uri),
							// Need to send 'selections' for multiple cursors
							select: TextEditorSelectionChangeEvent.selections[0]
						}
					};
					return setTimeout(function () {
						return _this.sendMessage(data);
					}, 0);
				};
			})(this)));
			this.subscriptions.push(vscode.workspace.onDidSaveTextDocument((function (_this) {
				return function (TextDocument) {
					// not sure how save all will work...
					return _this.sendFileEvents('save', TextDocument.uri);
				};
			})(this)));
			this.subscriptions.push(vscode.workspace.onDidCloseTextDocument((function (_this) {
				return function (TextDocument) {
					var base, base1;
					if(TextDocument.detachShareJsDoc) TextDocument.detachShareJsDoc();
					if (TextDocument.isUntitled) {
						return;
					}
					return _this.sendFileEvents('close', TextDocument.uri);
				};
			})(this)));
			// If this is messed up, try 'workspace.onDidOpenTextDocument'
			return this.subscriptions.push(vscode.workspace.onDidOpenTextDocument((function (_this) {
				return function (TextDocument) {
					if (!(TextDocument.uri.fsPath.match(new RegExp(_this.projectPath)) !== null)) {
						return;
					}
					return _this.sendFileEvents('open', TextDocument.uri);
				};
			})(this)));
		};

		return EventHandler;

	})();

	module.exports = EventHandler;

}).call(this);
