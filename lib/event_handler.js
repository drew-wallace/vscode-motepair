// Generated by CoffeeScript 1.10.0
(function () {
	var vscode = require('vscode'),
		crypto = require('crypto');

	var EventEmitter, EventHandler,
		indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	EventEmitter = require('events').EventEmitter;

	EventHandler = (function () {
		function EventHandler(remoteClient) {
			this.remoteClient = remoteClient;
			this.emitter = new EventEmitter;
			this.workspace = vscode.workspace;
			this.projectPath = this.workspace.rootPath;
			this.window = vscode.window;
			this.subscriptions = [];
			this.localChange = false;
			this.userEmail = this.workspace.getConfiguration('motepair.userEmail');
			this.lastCursorChange = new Date().getTime();
			this.remoteAction = false;
			this.syncTabsEvents = ['open', 'close'];
			this.fontSize = vscode.workspace.getConfiguration().get("editor.lineHeight") || vscode.workspace.getConfiguration().get("editor.fontSize") || 14;
			this.highlight = vscode.window.createTextEditorDecorationType({
				backgroundColor: 'rgba(31, 161, 93, 0.3)'
			});
			this.remoteCursor = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 0 0 2px",
				// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
				// before: {
				// 	backgroundColor: 'transparent',
				// 	contentIconPath: 'some default image url',
				// 	height: this.fontSize + 'px',
				// 	width: this.fontSize + 'px'
				// }
			});
			this.remoteCursorEnd = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 2px 0 0",
				// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
				// after: {
				// 	backgroundColor: 'transparent',
				// 	contentIconPath: 'some default image url',
				// 	height: this.fontSize + 'px',
				// 	width: this.fontSize + 'px'
				// }
			});
		}

		EventHandler.prototype.onopen = function (data) {
			var path;
			path = this.projectPath + "/" + data.file;
			this.remoteAction = true;
			this.workspace.openTextDocument(path);
			return setTimeout((function (_this) {
				return function () {
					return _this.remoteAction = false;
				};
			})(this), 300);
		};

		EventHandler.prototype.onclose = function (data) {
			// Apparently can't close other editors...
			// var closedItem;
			// closedItem = null;
			// this.window.visibleTextEditors().forEach(function (item) {
			// 	var ref1;
			// 	if ((item && item.document.uri.path) && ((ref1 = item.document.uri.path) != null ? ref1.indexOf(data.file) : void 0) >= 0) {
			// 		return closedItem = item;
			// 	}
			// });
			this.remoteAction = true;
			// this.window.activeTextEditor.hide();
			vscode.commands.executeCommand('workbench.action.closeActiveEditor');
			return setTimeout((function (_this) {
				return function () {
					return _this.remoteAction = false;
				};
			})(this), 300);
		};

		EventHandler.prototype.onsave = function (data) {
			return this.window.visibleTextEditors().forEach(function (item) {
				var ref1;
				if ((item && item.document.uri.path) && ((ref1 = item.document.uri.path) != null ? ref1.indexOf(data.file) : void 0) >= 0) {
					return item.document.save();
				}
			});
		};

		EventHandler.prototype.onselect = function (data) {
			var editor, ref1;
			editor = this.window.activeTextEditor();
			if (!((editor && editor.document.uri.path) && data.file === this.workspace.asRelativePath(editor.document.uri.path))) {
				return;
			}
			// if ((ref1 = editor.selectionMarker) != null) {
			// 	ref1.destroy();
			// }
			if (!data.select.start.compareTo(editor.selection.start)) {
				// if (editor.markBufferRange == null) {
				// 	return;
				// }
				var range = new vscode.Range(data.select.start, data.select.end);
				return editor.setDecorations(this.highlight, [range]);
			}
		};

		EventHandler.prototype.oncursor = function (data) {
			var editor, ref1;
			editor = this.window.activeTextEditor();
			if (!((editor && editor.document.uri.path) && data.file === this.workspace.asRelativePath(editor.document.uri.path))) {
				return;
			}

			// Need to loop through data.cursor in case multiple

			// Will re-enable the gravatar feature when vscode fixes the contentIcon bug: https://github.com/Microsoft/vscode/issues/11055
			// if(!this.remoteUserEmail) this.setGravatar(data.userEmail, Math.round(1.5 * this.fontSize));
			if(data.cursor.end.character === editor.document.lineAt(data.cursor.start.line).range.end.character) {
				editor.setDecorations(remoteCursorEnd, [data.cursor]);
				editor.setDecorations(remoteCursor, []);
			} else {
				editor.setDecorations(remoteCursor, [data.cursor]);
				editor.setDecorations(remoteCursorEnd, []);
			}
			// this.setGravatarDuration(editor);

			// I don't think I would want this feature by default.
			// Maybe as a dedicated command, or it could be setting defined
			// return editor.revealRange(data.cursor, vscode.TextEditorRevealType.InCenterIfOutsideViewport)
		};

		EventHandler.prototype.setGravatar = function (email, size) {
			this.remoteUserEmail = email;
			var emailHash, md5;
			if (!((email != null ? email.length : void 0) > 0)) {
				return;
			}
			md5 = crypto.createHash('md5');
			emailHash = md5.update(email).digest('hex');
			this.remoteCursor.dispose();
			this.remoteCursorEnd.dispose();
			this.remoteCursor = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 0 0 2px",
				before: {
					backgroundColor: 'transparent',
					contentIconPath: 'https://s.gravatar.com/avatar/' + emailHash + '?s=' + size,
					height: size + 'px',
					width: size + 'px'
				}
			});
			this.remoteCursorEnd = vscode.window.createTextEditorDecorationType({
				overviewRulerLane: '7',
				overviewRulerColor: 'rgb(31, 161, 93)',
				borderStyle: "solid",
				borderColor: "rgb(31, 161, 93)",
				borderWidth: "0 2px 0 0",
				after: {
					backgroundColor: 'transparent',
					contentIconPath: 'https://s.gravatar.com/avatar/' + emailHash + '?s=' + size,
					height: size + 'px',
					width: size + 'px'
				}
			});
			return;
		};

		EventHandler.prototype.setGravatarDuration = function (editor) {
			var gravatarDelay, now;
			gravatarDelay = 1500;
			now = new Date().getTime();
			if (now - this.lastCursorChange < gravatarDelay) {
				clearInterval(this.gravatarTimeoutId);
			}
			this.gravatarTimeoutId = setTimeout((function (_this) {
				return function () {
					editor.setDecorations(remoteCursor, []);
					return editor.setDecorations(remoteCursorEnd, []);
				};
			})(this), gravatarDelay);
			return this.lastCursorChange = now;
		};

		EventHandler.prototype.sendFileEvents = function (type, file) {
			// check the path coming in
			var data;
			data = {
				a: 'meta',
				type: type,
				data: {
					file: this.workspace.asRelativePath(file)
				}
			};
			if (!this.remoteAction) {
				return this.sendMessage(data);
			}
		};

		EventHandler.prototype.sendMessage = function (data) {
			var e, error;
			try {
				return this.remoteClient.send(JSON.stringify(data));
			} catch (error) {
				e = error;
				return this.emitter.emit('socket-not-opened');
			}
		};

		EventHandler.prototype.listen = function () {
			this.remoteClient.on('message', (function (_this) {
				return function (event) {
					var ref1;
					event = JSON.parse(event);
					if (_this["on" + event.type] != null) {
						if (_this.workspace.getConfiguration.get('motepair.syncTabs') || (ref1 = event.type, indexOf.call(_this.syncTabsEvents, ref1) < 0)) {
							return _this["on" + event.type](event.data);
						}
					}
				};
			})(this));
			this.subscriptions.push(this.window.onDidChangeTextEditorSelection((function (_this) {
				return function (selections, TextEditor) {
					var data;
					data = {
						a: 'meta',
						type: 'cursor',
						data: {
							file: _this.workspace.asRelativePath(TextEditor.document.uri),
							// Need to send 'selections' for multiple cursors
							cursor: selections[0].active,
							userEmail: _this.userEmail
						}
					};
					return setTimeout(function () {
						return _this.sendMessage(data);
					}, 0);
				};
			})(this)));
			this.subscriptions.push(this.window.onDidChangeTextEditorSelection((function (_this) {
				return function (selections, TextEditor) {
					var data;
					data = {
						a: 'meta',
						type: 'select',
						data: {
							file: _this.workspace.asRelativePath(TextEditor.document.uri),
							// Need to send 'selections' for multiple cursors
							select: selections[0]
						}
					};
					return setTimeout(function () {
						return _this.sendMessage(data);
					}, 0);
				};
			})(this)));
			this.subscriptions.push(this.workspace.onDidSaveTextDocument((function (_this) {
				return function (TextDocument) {
					// not sure how save all will work...
					return _this.sendFileEvents('save', TextDocument.uri);
				};
			})(this)));
			this.subscriptions.push(this.workspace.onDidCloseTextDocument((function (_this) {
				return function (TextDocument) {
					var base, base1;
					if(TextDocument.detachShareJsDoc) TextDocument.detachShareJsDoc();
					if (TextDocument.isUntitled) {
						return;
					}
					return _this.sendFileEvents('close', TextDocument.uri);
				};
			})(this)));
			// If this is messed up, try 'workspace.onDidOpenTextDocument'
			return this.subscriptions.push(this.window.onDidChangeActiveTextEditor((function (_this) {
				return function (TextEditor) {
					if (!(_this.workspace.asRelativePath(TextEditor.document.fileName).match(new RegExp(_this.projectPath)) !== null)) {
						return;
					}
					return _this.sendFileEvents('open', TextEditor.document.uri);
				};
			})(this)));
		};

		return EventHandler;

	})();

	module.exports = EventHandler;

}).call(this);
